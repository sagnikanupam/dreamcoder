import pandas as pd

import binutil
import dreamcoder.domains.mathDomain.mathDomainPrimitives as mdp
import mathDomainPrefixConversion as mdpc

functions_dict = {
    '(_swap': mdp._swap, 
    '(_add': mdp._add, 
    '(_sub': mdp._sub, 
    '(_mult': mdp._mult, 
    '(_div': mdp._div, 
    '(_rrotate': mdp._rrotate, 
    '(_lrotate': mdp._lrotate, 
    '(_simplify': mdp._simplify, 
    '(_dist': mdp._dist, 
}

def replacements(s):
    """
    Given a string of a program generated by DreamCoder, replaces all mathDomain primitive names with their corresponding functions_dict index name.

    Inputs: 
        - s is is a string containing a lambda expression describing a program generated by DreamCoder which is a series of functions composed of primitives. E.g. - (lambda (#(lambda (mathDomain_simplify (mathDomain_dist $0 1) 0)) $0)) 
    
    Returns:
        - a string with all the mathDomain primitive names replaced. This output shall henceforth be referred to as a solution program expression.

    """
    replacements_dict = {'mathDomain_swap': '_swap', 'mathDomain_add': '_add', 'mathDomain_sub': '_sub', 'mathDomain_mult': '_mult', 'mathDomain_div': '_div', 'mathDomain_rrotate': '_rrotate', 'mathDomain_lrotate': '_lrotate', 'mathDomain_simplify': '_simplify', 'mathDomain_dist':'_dist'}
    for i in range(10):
        replacements_dict['mathDomain_'+str(i)] = str(i)
    for or_text in replacements_dict.keys():
        s = s.replace(or_text, replacements_dict[or_text])
    return s

def dsSolnFormat(dsSolnPath, outputSolnPath):
    '''
    Given a .csv file containing solutions copied from the terminal output of DreamSolver, pass the solutions through replacements() and modify the solutions to make them more readable.
    
    Inputs:
        - dcSolnPath is a string containing a path to the .csv file containing the DreamSolver solution e.g.'bin/tempLargeDatasetSolns_1.csv'
        - outputSolnPath is a string containing a path to the .csv where we would like to store our modified DreamSolver solutions

    Returns:
        None
    '''

    df = pd.read_csv(dsSolnPath)
    equation_numbering_list = []
    reconstructed_solution_list = []

    for i in range(df.shape[0]):
        or_eq = df.loc[i]['output']
        equation_numbering_list.append(or_eq.split(' ')[1][2:])
        reconstructed_solution_list.append(replacements(or_eq[or_eq.find('(') : or_eq.rfind(')')+1]))
        
    df['equation_number'] = equation_numbering_list
    df['rec_soln'] = reconstructed_solution_list
    print(df)

    df.to_csv(outputSolnPath)

def matchBr(s, ind):
    """
    Given an opening bracket at position ind in string s, find the  position of the corresponding closing bracket.

    Inputs: 
    - s is a string denoting the solution program expression (already processed by replacements())
    - ind is an integer denoting the starting position of the start bracket '('

    Returns: 
    - an integer denoting position of closing bracket. If start index does not have an open bracket or no closing brackets close the starting bracket, returns None.
    """
    brPair = 0
    for j in range(ind, len(s)):
        if s[j]=="(":
            brPair+=1
        if s[j]==")":
            brPair-=1
        if brPair==0:
            if j==ind:
                return None
            return j
    return None

def evaluate(s, arg):
    """
    Given a solution program expression, generate mathematical solutions as a list of prefix expressions, stored as a string separated by |.

    Inputs: 
        - s is a string denoting the solution program expression (already processed by replacements())
        - arg is a string containing an equation as a prefix-tree expression. This is the equation to be solved.

    Returns:
        - a list comprising of all the steps of the DreamCoder solution i.e. all the steps we generate after evaluating abstractions 
    """

    init_split = s.split(" ")
    if s=="":
        return [arg]
    if arg=="":
        return [s]
    if init_split[0]=="$0":
        return [arg]
    if init_split[0].isnumeric():
        return [int(init_split[0])]
    if init_split[0]=="(lambda" or init_split[0]=="(#(lambda":
        subExpStart = 8 if init_split[0]=="(lambda" else 2
        subExpEnd = -1
        funcEnd = matchBr(s, subExpStart)
        if funcEnd!=None: 
            argEnd =  matchBr(s, funcEnd+2)
            if argEnd!=None:
                newFunc = s[subExpStart:funcEnd+1]
                newArgFunc = s[funcEnd+2:argEnd+1]
                #print("New Func is: "+newFunc)
                #print("New ArgFunc is: "+newArgFunc)
                #print("Currently, func is: "+s)
                #print("Currently, arg is: "+arg+"\n")
                evalArg = evaluate(newArgFunc, arg)
                #print("Evaluated argument of " +s+" and " +arg + " is " +evalArg)
                return evalArg+evaluate(newFunc, evalArg[-1]) #evalArg is appended as it is an output produced by an abstraction
            else:
                newFunc = s[subExpStart:funcEnd+1]
                newArgFunc = s[funcEnd+2:subExpEnd]
                #print("New Func is: "+newFunc)
                #print("New ArgFunc is: "+newArgFunc)
                #print("Currently, func is: "+s)
                #print("Currently, arg is: "+arg+"\n")
                evalArg = evaluate(newArgFunc, arg)
                #print("Evaluated argument of " +s+" and " +arg + " is " +evalArg)
                return evaluate(newFunc, evalArg[-1]) #evalArg is not appended as it is simply a substring
        else:
            newFunc = s[subExpStart:-1]
            print("New Func is: "+newFunc)
            return evaluate(newFunc, arg)
    
    if init_split[0] in functions_dict.keys():
        if init_split[1][0]=="(":
            arg1Start = len(init_split[0])+1
            arg1End = matchBr(s, arg1Start)
            arg2Start = arg1End + 2
            arg2End = -1
            if s[arg2Start]=="(":
                arg2End = matchBr(s, arg2Start)
            newArg1 = s[arg1Start:arg1End+1]
            newArg2 = s[arg1End+2:arg2End]
            #print("New Arg1 is: "+newArg1)
            #print("New Arg2 is: "+newArg2)
            #print("Currently, func is: "+s)
            #print("Currently, arg is: "+arg+"\n")
            evalNewArg1 = evaluate(newArg1, arg)
            evalNewArg2 = evaluate(newArg2, arg)
            #print("Evaluation: "+ s + " and " + arg + " result in " + str(evalNewArg1) + " and " + str(evalNewArg2))
            return evalNewArg1 + [functions_dict[init_split[0]](evalNewArg1[-1], evalNewArg2[-1])] #evalNewArg1 is appended as it is an output produced by an abstraction 
        else:
            newArg1 = init_split[1]
            newArg2 = init_split[2][:-1]
            if (init_split[2][0]=="("):
                arg2Start = len(init_split[0])+len(init_split[1])+2
                newArg2 = s[arg2Start:matchBr(arg2Start)+1]
            #print("New Arg1 is: "+newArg1)
            #print("New Arg2 is: "+newArg2)
            #print("Currently, func is: "+s)
            #print("Currently, arg is: "+arg+"\n")
            evalNewArg1 = evaluate(newArg1, arg)
            evalNewArg2 = evaluate(newArg2, arg)
            #print("Evaluation: "+ s + " and " + arg + " result in " + str(evalNewArg1) + " and " + str(evalNewArg2))
            return [functions_dict[init_split[0]](evalNewArg1[-1], evalNewArg2[-1])] #evalNewArg1 is not appended as it is simply a substring
    return [s]

def computeMetrics(steps):
    """
    Takes a list of solution steps (in prefix format) as input and computes their conciseness metric function value, f(s)

    Inputs:
        - steps is a list of strings containing equations in prefix format, which can be accepted by mdp.treefy()
    Returns:
        - an integer denoting the total value of the metric function for that equation
    """
    total_metric = 0
    for ind in range(1, len(steps)):
        total_metric+=mdp._metric(steps[ind-1],steps[ind])
    return total_metric

def clSolnEval(clSolnPath, outputSolnPath):
    '''
    Given a .csv file containing solutions generated by ConPoLe or Lemma, convert the solutions into lists of steps in prefix notation, and then compute each solution's metric function.
    
    Inputs:
        - clSolnPath is a string containing a path to the .csv file containing the ConPoLe/Lemma solutions e.g.'bin/tempLargeDatasetSolns_1.csv'
        - outputSolnPath is a string containing a path to the .csv where we would like to store our ConPoLe/Lemma solutions alongside their metric function values.
    
    Returns:
        None
    '''
    df = pd.read_csv(clSolnPath)
    metrics = []
    for i in range(df.shape[0]):
        str_soln = df.loc[i]['soln']
        str_eq = df.loc[i]['eqn']
        steps = str_soln.split('|')
        steps = [str_eq]+steps
        prefix_steps = [mdpc.infix_to_prefix_conversion(step) for step in steps]
        metrics.append(computeMetrics(prefix_steps))
    df['metrics'] = metrics
    df.to_csv(outputSolnPath)

def dsSolnEval(dsSolnPath, outputSolnPath):
    '''
    Given a .csv file containing solution program expressions generated by DreamSolver and passed through replacement(), generate solutions from the expression, convert the solutions into lists of steps in prefix notation, and then compute each solution's metric function.
    
    Inputs:
        - dsSolnPath is a string containing a path to the .csv file containing the DreamSolver solution program expressions e.g.'bin/tempLargeDatasetSolns_1.csv'
        - outputSolnPath is a string containing a path to the .csv where we would like to store our DreamSolver solutions alongside their metric function values.
    
    Returns:
        None
    '''
    df = pd.read_csv(dsSolnPath)
    metrics = []
    steps = []
    for i in range(df.shape[0]):
        str_soln = df.loc[i]['soln']
        str_eq = df.loc[i]['eqn']
        prefix_steps = evaluate(str_soln, str_eq)
        steps.append('|'.join(prefix_steps))
        steps = [str_eq]+steps
        metrics.append(computeMetrics(prefix_steps))
    df['steps'] = steps
    df['metrics'] = metrics
    df.to_csv(outputSolnPath)

if __name__ == "__main__":

    '''
    Tests for evaluate() function for step-by-step solution generation
    '''

    '''
    test_case_1 = "(lambda $0)" #te273
    test_case_2 = "(lambda (#(lambda (_simplify (_dist $0 1) 0)) $0))" #te28
    test_case_3 = "(lambda (#(lambda (#(lambda (_simplify (_swap $0 0) 0)) (_rrotate (_swap $0 3) 2))) (#(lambda (_simplify (_rrotate (_sub (_simplify $0 0) 3) 1) 0)) (#(lambda (_simplify (_rrotate (_sub (_simplify $0 0) 3) 1) 0)) (_swap (#(lambda (#(lambda (_simplify (_swap $0 0) 0)) (_rrotate (_swap $0 3) 2))) $0) 1)))))" #te40

    print(evaluate(test_case_1, "(= (x) (/ (-1) (2)))"))
    print(evaluate(test_case_2, "(= (+ (* (-1) (x)) (* (2) (x))) (-3))"))
    print(evaluate(test_case_3, "(= (1) (+ (* (2) (x)) (3)))"))
    '''
